#!/bin/bash
# Written by Uwe Hermann <uwe@hermann-uwe.de>, released as public domain.
# Modified by Piotr Esden-Tempski <piotr@esden.net>, released as public domain.

#
# Requirements (example is for Debian, replace package names as needed):
#
# apt-get install flex bison libgmp3-dev libmpfr-dev libncurses5-dev \
# libmpc-dev autoconf texinfo build-essential
#

# Stop if any command fails
set -e

TARGET=arm-none-eabi		# Or: TARGET=arm-elf
PREFIX=${HOME}/arm-none-eabi	# Install location of your final toolchain
PARALLEL=			# Or: PARALLEL="-j 5" for 4 CPUs
DARWIN_OPT_PATH=/opt/local	# Path in which MacPorts or Fink is installed

BINUTILS=binutils-2.20
GCC=gcc-4.5.1
NEWLIB=newlib-1.18.0
GDB=gdb-7.2
LIBCMSIS=v1.10-2
LIBSTM32=v3.0.0-1
LIBSTM32USB=v3.0.1-1
LIBOPENSTM32=master
LIBSTM32_EN=0
LIBOPENSTM32_EN=0

SUMMON_DIR=$(pwd)
SOURCES=${SUMMON_DIR}/sources
STAMPS=${SUMMON_DIR}/stamps

export PATH="${PREFIX}/bin:${PATH}"

GCCFLAGS=
GDBFLAGS=
BINUTILFLAGS=

# Fetch a versioned file from a URL
function fetch {
    if [ ! -e ${STAMPS}/$1.fetch ]; then
        echo "Downloading $1 sources..."
        wget -c --no-passive-ftp $2
        touch ${STAMPS}/$1.fetch
    fi
}

# Log a message out to the console
function log {
    echo "******************************************************************"
    echo "* $*"
    echo "******************************************************************"
}

# Unpack an archive
function unpack {
    # Use 'auto' mode decompression.  Replace with a switch if tar doesn't support -a
    tar xvaf $1
}

case "$(uname)" in
	Linux)
	echo "Found Linux OS."
	;;
	Darwin)
	echo "Found Darwin OS."
	GCCFLAGS="${GCCFLAGS} \
                  --with-gmp=${DARWIN_OPT_PATH} \
	          --with-mpfr=${DARWIN_OPT_PATH} \
	          --with-mpc=${DARWIN_OPT_PATH} \
		  -with-libiconv-prefix=${DARWIN_OPT_PATH}"
	;;
	*)
	echo "Found unknown OS. Aborting!"
	exit 1
	;;
esac

mkdir -p ${STAMPS} ${SOURCES}

cd ${SOURCES}

fetch ${BINUTILS} http://ftp.gnu.org/gnu/binutils/${BINUTILS}.tar.bz2
fetch ${GCC} ${GCC_URL}
fetch ${NEWLIB} ftp://sources.redhat.com/pub/newlib/${NEWLIB}.tar.gz
fetch ${GDB} http://ftp.gnu.org/gnu/gdb/${GDB}.tar.bz2

if [ ${LIBSTM32_EN} != 0 ]; then
if [ ! -e libcmsis-${LIBCMSIS}.tar.bz2 ]; then
	echo "Cloning libcmsis sources..."
	git clone git://git.open-bldc.org/libcmsis.git
        cd libcmsis
        git archive --format=tar --prefix=libcmsis-${LIBCMSIS}/ ${LIBCMSIS} | \
            bzip2 --stdout > ../libcmsis-${LIBCMSIS}.tar.bz2
        cd ..
        rm -rf libcmsis
fi

if [ ! -e libstm32-${LIBSTM32}.tar.bz2 ]; then
	echo "Cloning libstm32 sources..."
	git clone git://git.open-bldc.org/libstm32.git
        cd libstm32
        git archive --format=tar --prefix=libstm32-${LIBSTM32}/ ${LIBSTM32} | \
            bzip2 --stdout > ../libstm32-${LIBSTM32}.tar.bz2
        cd ..
        rm -rf libstm32
fi

if [ ! -e libstm32usb-${LIBSTM32USB}.tar.bz2 ]; then
	echo "Cloning libstm32usb sources..."
	git clone git://git.open-bldc.org/libstm32usb.git
        cd libstm32usb
        git archive --format=tar --prefix=libstm32usb-${LIBSTM32USB}/ ${LIBSTM32USB} | \
            bzip2 --stdout > ../libstm32usb-${LIBSTM32USB}.tar.bz2
        cd ..
        rm -rf libstm32usb
fi
fi

if [ ${LIBOPENSTM32_EN} != 0 ]; then
if [ ! -e libopenstm32-${LIBOPENSTM32}.tar.bz2 ]; then
	echo "Cloning libopenstm32 sources..."
	git clone git://libopenstm32.git.sourceforge.net/gitroot/libopenstm32/libopenstm32
        cd libopenstm32
        git archive --format=tar --prefix=libopenstm32-${LIBOPENSTM32}/ ${LIBOPENSTM32} | \
            bzip2 --stdout > ../libopenstm32-${LIBOPENSTM32}.tar.bz2
        cd ..
        rm -rf libopenstm32
fi
fi

cd ${SUMMON_DIR}

if [ ! -e build ]; then
    mkdir build
fi

if [ ! -e ${STAMPS}/${BINUTILS}.build ]; then
    log "Unpacking ${BINUTILS}"
    unpack ${SOURCES}/${BINUTILS}.tar.bz2
    cd build
    log "Configuring ${BINUTILS}"
    ../${BINUTILS}/configure --target=${TARGET} \
                           --prefix=${PREFIX} \
                           --enable-interwork \
                           --enable-multilib \
                           --with-gnu-as \
                           --with-gnu-ld \
                           --disable-nls \
                           --disable-werror \
			   ${BINUTILFLAGS}
    log "Building ${BINUTILS}"
    make ${PARALLEL}
    log "Installing ${BINUTILS}"
    make install
    cd ..
    log "Cleaning up ${BINUTILS}"
    touch ${STAMPS}/${BINUTILS}.build
    rm -rf build/* ${BINUTILS}
fi

if [ ! -e ${STAMPS}/${GCC}-boot.build ]; then
    log "Unpacking ${GCC}-boot"
    unpack ${SOURCES}/${GCC}.tar.bz2
    cd build
    log "Configuring ${GCC}-boot"
    ../${GCC}/configure --target=${TARGET} \
                      --prefix=${PREFIX} \
                      --enable-interwork \
                      --enable-multilib \
                      --enable-languages="c" \
                      --with-newlib \
                      --without-headers \
                      --disable-shared \
                      --with-gnu-as \
                      --with-gnu-ld \
                      --disable-nls \
                      --disable-werror \
		      ${GCCFLAGS}
    log "Building ${GCC}-boot"
    make ${PARALLEL} all-gcc
    log "Installing ${GCC}-boot"
    make install-gcc
    cd ..
    log "Cleaning up ${GCC}-boot"
    touch ${STAMPS}/${GCC}-boot.build
    rm -rf build/* ${GCC}
fi

if [ ! -e ${STAMPS}/${NEWLIB}.build ]; then
    log "Unpacking ${NEWLIB}"
    unpack ${SOURCES}/${NEWLIB}.tar.gz
    cd build
    log "Configuring ${NEWLIB}"
    ../${NEWLIB}/configure --target=${TARGET} \
                         --prefix=${PREFIX} \
                         --enable-interwork \
                         --enable-multilib \
                         --with-gnu-as \
                         --with-gnu-ld \
                         --disable-nls \
                         --disable-werror \
                         --disable-newlib-supplied-syscalls
    log "Building ${NEWLIB}"
    make ${PARALLEL}
    log "Installing ${NEWLIB}"
    make install
    cd ..
    log "Cleaning up ${NEWLIB}"
    touch ${STAMPS}/${NEWLIB}.build
    rm -rf build/* ${NEWLIB}
fi

# Yes, you need to build gcc again!
if [ ! -e ${STAMPS}/${GCC}.build ]; then
    log "Unpacking ${GCC}"
    unpack ${SOURCES}/${GCC}.tar.bz2
    cd build
    log "Configuring ${GCC}"
    ../${GCC}/configure --target=${TARGET} \
                      --prefix=${PREFIX} \
                      --enable-interwork \
                      --enable-multilib \
                      --enable-languages="c,c++" \
                      --with-newlib \
                      --disable-shared \
                      --with-gnu-as \
                      --with-gnu-ld \
		      --disable-nls \
                      --disable-werror \
	 	     ${GCCFLAGS}
    log "Building ${GCC}"
    make ${PARALLEL}
    log "Installing ${GCC}"
    make install
    cd ..
    log "Cleaning up ${GCC}"
    touch ${STAMPS}/${GCC}.build
    rm -rf build/* ${GCC}
fi

if [ ! -e ${STAMPS}/${GDB}.build ]; then
    log "Unpacking ${GDB}"
    unpack ${SOURCES}/${GDB}.tar.bz2
    cd build
    log "Configuring ${GDB}"
    ../${GDB}/configure --target=${TARGET} \
                      --prefix=${PREFIX} \
                      --enable-interwork \
                      --enable-multilib \
                      --disable-werror \
		      ${GDBFLAGS}
    log "Building ${GDB}"
    make ${PARALLEL}
    log "Installing ${GDB}"
    make install
    cd ..
    log "Cleaning up ${GDB}"
    touch ${STAMPS}/${GDB}.build
    rm -rf build/* ${GDB}
fi

if [ ${LIBSTM32_EN} != 0 ]; then
if [ ! -e .libcmsis-${LIBCMSIS}.build ]; then
    log "Unpacking libcmsis-${LIBCMSIS}"
    unpack ${SOURCES}/libcmsis-${LIBCMSIS}.tar.bz2
    cd libcmsis-${LIBCMSIS}
    log "Building libcmsis-${LIBCMSIS}"
    make arch_prefix=${TARGET} prefix=${PREFIX}
    log "Installing libcmsis-${LIBCMSIS}"
    make arch_prefix=${TARGET} prefix=${PREFIX} install
    cd ..
    log "Cleaning up libcmsis-${LIBCMSIS}"
    touch .libcmsis-${LIBCMSIS}.build
    rm -rf libcmsis-${LIBCMSIS}
fi

if [ ! -e .libstm32-${LIBSTM32}.build ]; then
    log "Unpacking libstm32-${LIBSTM32}"
    unpack ${SOURCES}/libstm32-${LIBSTM32}.tar.bz2
    cd libstm32-${LIBSTM32}
    log "Building libstm32-${LIBSTM32}"
    make arch_prefix=${TARGET} prefix=${PREFIX}
    log "Installing libstm32-${LIBSTM32}"
    make arch_prefix=${TARGET} prefix=${PREFIX} install
    cd ..
    log "Cleaning up libstm32-${LIBSTM32}"
    touch .libstm32-${LIBSTM32}.build
    rm -rf libstm32-${LIBSTM32}
fi

if [ ! -e .libstm32usb-${LIBSTM32USB}.build ]; then
    log "Unpacking libstm32usb-${LIBSTM32USB}"
    unpack ${SOURCES}/libstm32usb-${LIBSTM32USB}.tar.bz2
    cd libstm32usb-${LIBSTM32USB}
    log "Building libstm32usb-${LIBSTM32USB}"
    make arch_prefix=${TARGET} prefix=${PREFIX}
    log "Installing libstm32usb-${LIBSTM32USB}"
    make arch_prefix=${TARGET} prefix=${PREFIX} install
    cd ..
    log "Cleaning up libstm32usb-${LIBSTM32USB}"
    touch .libstm32usb-${LIBSTM32USB}.build
    rm -rf libstm32usb-${LIBSTM32USB}
fi
fi

if [ $LIBOPENSTM32_EN != 0 ]; then
    log "Unpacking libopenstm32-${LIBOPENSTM32}"
    unpack ${SOURCES}/libopenstm32-${LIBOPENSTM32}.tar.bz2
    cd libopenstm32-${LIBOPENSTM32}
    log "Building libopenstm32-${LIBOPENSTM32}"
    make PREFIX=${TARGET} DESTDIR=${PREFIX}
    log "Installing libopenstm32-${LIBOPENSTM32}"
    make PREFIX=${TARGET} DESTDIR=${PREFIX} install
    cd ..
    log "Cleaning up libopenstm32-${LIBOPENSTM32}"
    touch .libopenstm32-${LIBOPENSTM32}.build
    rm -rf libopenstm32-${LIBOPENSTM32}
fi
